#nullable disable

// Показать числа от -N до N

/*int A = -5;
int B = 5;
Console.WriteLine($"{A}..{B}");


//Набор правил при написании кода:
//1. Нужно менять имя переменных;
//2. Имя метода, отражающее суть того,что делаем;
//3. Имена аргументов.*/

//Для именования переменных используйте нотацию Camel.
//Используйте неявную типизацию (var)для локальных переменных в случаях,когда тип переменной
//понятен из правой части назначения или когда точный тип не важен.

//Пример

/*using System.Linq;    //подключаем системные библиотеки

int a = 12;    // var 
//Console.WriteLine(a.GetType().Name);// в консоли выйдет тип данных

var data = new int[]{1,2,3,4}
          .Where (e=> e > 0)                      // выборка элементов
          .Select( e => new{q = e, w = e + 1});


Console.WriteLine(data.GetType());  // выдаст тип переменной


// счетчики в циклах от и до :  i j k l m n   - выдумывать большу ничего не надо

// инициализируйте переменные перед объявлением,если такая возможность есть


//устоявшиеся модели написания кода - паттерны  и антипаттерны - как не нужно писать код,*/



// Читается лучше,если
/*
bool isEven (int value)
{                     
    return value %2 == 0 ;      
}

// bool isEven (int value) => value % 2 == 0;
// **var isEven = (int v) => v % 2 == 0;


// Если метод асинхронный , он заканчивается на "Async"
// GetStreamAsync()*/


//Пример кода: описание экрана

/*string caption = "Intensive C# Demo text";
int screenWidthPosition = (Console.WindowWitdth - caption.Length)/2;
int screenHeightPosition = Console.WindowHeight / 2;

DrawText(caption, screenWidthPosition, screenHeightPosition);

DrawText(text:caption, 
         left:screenWidthPosition,
         top: screenHeightPosition);*/


  // Решение квадратного уравнения:

   /*public Roots Solve(double a, double b, double c)
  {
      var d = b * b - 4 * a * c;
      double x1 = (-b + Math.Sqrt(d)) / (2 * a);
      double x2 = (-b - Math.Sqrt(d)) / (2 * a);
      return new Roots{X1 = x1, X2 = x2};

  }  */


 /* // В случайных точках консоли вывести случайные числа


  Random r = new Random();

  Console.CursorVisible = false;
  while(true)
  {
     Console.SetCursorPosition
     (left: r.Next(Console.WindowWidth),
     top: r.Next(Console.WindowHeight));

     Console.Write(r.Next(10));
     Thread.Sleep(1000);  
  }
  */



//Парсинг входной строки



//using System.Linq;      // код можно сделать короче



string text = "(1,2) (2,3) (4,5) (6,7)"  //в строке находятся парные координаты точек фигуры
              .Replace ("(","")          // на выходе будет строка вообще без скобок
              .Replace (")","");                      
var data = text.Split(" ")     //сиволом - разделителем здесь будет пробел,разбили на 4 точки строку
               .Select(item => item.Split(','))  //создаем массив в массиве,выборка элем.
               .Select(e =>(int.Parse(e[0]),int.Parse(e[1]))) //это уже не массив, а массив кортежей
               .ToArray();     //вместо var можно было string[],var - чтоб не менять тип данных
                               // .ToArray() - преобразовываем в массив

for(int i = 0; i < data.Length; i++)
{

    Console.WriteLine(data[i].Item1*10);// Item1((координата x * 10)) 10,20,40,60  на выходе
   
   
   // for(int k = 0; k < data[i].Length; k++)  // для массива массивов
   // {
    //   Console.WriteLine(data[i][k]);

   // }
    
    
    //Console.WriteLine();  //разделяем точки пробелом
}

// Можем сделать

//.Select(e =>(x = int.Parse(e[0]), y = int.Parse(e[1]))) x-1я коорд.массива,конверт.в число 
//.Where( e => e.x % 2 == 0) проверка условия - дайте такие пары,где 1 координата чётная.
//.Select(point =>(point.x * 10, point.y + 10))-выборка набора на предыдущем этапе,хотим
                                             //сделать увеличение 1 и 2 координаты.

//.ToArray(); все кладем в массив  и далее цикл и печать,   

//SOLID 
// Класс должен быть ответственнен лишь за что-то одно.

//Принцип открытости-закрытости
//Программные сущности (классы, модули, функции) должны быть открыты для расширения, 
//но не для модификации.

//Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.

//Принцип разделения интерфейса
//Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента.
 //Клиенты не должны зависеть от интерфейсов, которые они не используют.


//Принцип инверсии зависимостей
//Объектом зависимости должна быть абстракция, а не что-то конкретное.

//Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
//Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.



